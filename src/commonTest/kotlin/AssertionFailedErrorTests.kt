/*
 * Copyright 2015-2023 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.willowtreeapps.opentest4k

import kotlin.test.*

/**
 * Unit tests for [AssertionFailedError].
 *
 * @author Marc Philipp
 * @author Sam Brannen
 * @since 1.0
 */
class AssertionFailedErrorTests {

    @Test
    fun defaultConstructorUsesEmptyMessage() {
        assertEquals(EMPTY, assertionFailedError().message)
    }

    @Test
    fun nullMessageIsConvertedToEmptyMessage() {
        assertEquals(EMPTY, assertionFailedError().message)
        assertEquals(EMPTY, assertionFailedError(null, null).message)
        assertEquals(EMPTY, assertionFailedError(null, "foo", "bar").message)
        assertEquals(EMPTY, assertionFailedError(null, "foo", "bar", null).message)
    }

    @Test
    fun blankMessageIsConvertedToEmptyMessage() {
        assertEquals(EMPTY, assertionFailedError(BLANK).message)
        assertEquals(EMPTY, assertionFailedError(BLANK, null).message)
        assertEquals(EMPTY, assertionFailedError(BLANK, "foo", "bar").message)
        assertEquals(EMPTY, assertionFailedError(BLANK, "foo", "bar", null).message)
    }

    @Test
    fun toStringChecks() {
        val className = "${javaOnlyString("org.opentest4j.")}AssertionFailedError"
        assertEquals(className, assertionFailedError().toString())
        assertEquals("$className: message", assertionFailedError("message").toString())

        assertEquals(className, assertionFailedError(null, "foo", "bar").toString())
        assertEquals(className, assertionFailedError(null, RuntimeException()).toString())
        assertEquals(className, assertionFailedError(null, "foo", "bar", RuntimeException()).toString())

        assertEquals(className, assertionFailedError(EMPTY).toString())
        assertEquals(className, assertionFailedError(EMPTY, "foo", "bar").toString())
        assertEquals(className, assertionFailedError(EMPTY, RuntimeException()).toString())
        assertEquals(className, assertionFailedError(EMPTY, "foo", "bar", RuntimeException()).toString())

        assertEquals(className, assertionFailedError(BLANK).toString())
        assertEquals(className, assertionFailedError(BLANK, "foo", "bar").toString())
        assertEquals(className, assertionFailedError(BLANK, RuntimeException()).toString())
        assertEquals(className, assertionFailedError(BLANK, "foo", "bar", RuntimeException()).toString())

        assertEquals("$className: message", assertionFailedError("message").toString())
        assertEquals("$className: message", assertionFailedError("message", "foo", "bar").toString())
        assertEquals("$className: message", assertionFailedError("message", RuntimeException()).toString())
        assertEquals(
            "$className: message",
            assertionFailedError("message", "foo", "bar", RuntimeException()).toString()
        )
    }

    @Test
    fun messageAndCauseAreStored() {
        val cause = RuntimeException("cause")

        val error = assertionFailedError("my message", cause)

        assertEquals("my message", error.message)
        assertEquals(cause, error.cause)
        assertFalse(error.isExpectedDefined)
        assertFalse(error.isActualDefined)
    }

    @Test
    fun expectedAndActualValuesAreStored() {
        val errorWithExpectedAndActual = assertionFailedError(null, "foo", "bar")
        assertTrue(errorWithExpectedAndActual.isExpectedDefined)
        assertEquals("foo", errorWithExpectedAndActual.expected?.value)
        assertTrue(errorWithExpectedAndActual.isActualDefined)
        assertEquals("bar", errorWithExpectedAndActual.actual?.value)
    }

    @Test
    fun returnsNullForExpectedAndActualWhenNotPassedToConstructor() {
        val errorWithoutExpectedAndActual = assertionFailedError()
        assertFalse(errorWithoutExpectedAndActual.isExpectedDefined)
        assertNull(errorWithoutExpectedAndActual.expected)
        assertFalse(errorWithoutExpectedAndActual.isActualDefined)
        assertNull(errorWithoutExpectedAndActual.actual)
    }
}

const val EMPTY = ""
const val BLANK = "   "